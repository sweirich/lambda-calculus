(* generated by Ott 0.33, locally-nameless lngen from: ./lc.ott *)
Require Import Metalib.Metatheory.
Require Export Metalib.LibLNgen. 

(** syntax *)
Definition tmvar : Set := var. (*r variables *)

Definition j : Set := nat.

Inductive tm : Set :=  (*r terms *)
 | var_b (_:nat) (*r variables *)
 | var_f (x:tmvar) (*r variables *)
 | abs (t:tm) (*r abstractions *)
 | app (t:tm) (u:tm) (*r function application, list indexing *)
 | lit (k:j)
 | add : tm
 | tnil : tm
 | tcons (t:tm) (u:tm)
 | choice (t1:tm) (t2:tm)
 | fail : tm
 | ex (t:tm)
 | seq (t1:tm) (t2:tm)
 | unify (t1:tm) (t2:tm)
 | one (t:tm)
 | all (t:tm).

Definition relation : Type := tm -> tm -> Prop.

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_tm_wrt_tm_rec (k:nat) (t_5:tm) (t__6:tm) {struct t__6}: tm :=
  match t__6 with
  | (var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => var_b nat
        | inleft (right _) => t_5
        | inright _ => var_b (nat - 1)
      end
  | (var_f x) => var_f x
  | (abs t) => abs (open_tm_wrt_tm_rec (S k) t_5 t)
  | (app t u) => app (open_tm_wrt_tm_rec k t_5 t) (open_tm_wrt_tm_rec k t_5 u)
  | (lit k) => lit k
  | add => add 
  | tnil => tnil 
  | (tcons t u) => tcons (open_tm_wrt_tm_rec k t_5 t) (open_tm_wrt_tm_rec k t_5 u)
  | (choice t1 t2) => choice (open_tm_wrt_tm_rec k t_5 t1) (open_tm_wrt_tm_rec k t_5 t2)
  | fail => fail 
  | (ex t) => ex (open_tm_wrt_tm_rec (S k) t_5 t)
  | (seq t1 t2) => seq (open_tm_wrt_tm_rec k t_5 t1) (open_tm_wrt_tm_rec k t_5 t2)
  | (unify t1 t2) => unify (open_tm_wrt_tm_rec k t_5 t1) (open_tm_wrt_tm_rec k t_5 t2)
  | (one t) => one (open_tm_wrt_tm_rec k t_5 t)
  | (all t) => all (open_tm_wrt_tm_rec k t_5 t)
end.

Definition open_tm_wrt_tm t_5 t__6 := open_tm_wrt_tm_rec 0 t__6 t_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_tm *)
Inductive lc_tm : tm -> Prop :=    (* defn lc_tm *)
 | lc_var_f : forall (x:tmvar),
     (lc_tm (var_f x))
 | lc_abs : forall (t:tm),
      ( forall x , lc_tm  ( open_tm_wrt_tm t (var_f x) )  )  ->
     (lc_tm (abs t))
 | lc_app : forall (t u:tm),
     (lc_tm t) ->
     (lc_tm u) ->
     (lc_tm (app t u))
 | lc_lit : forall (k:j),
     (lc_tm (lit k))
 | lc_add : 
     (lc_tm add)
 | lc_tnil : 
     (lc_tm tnil)
 | lc_tcons : forall (t u:tm),
     (lc_tm t) ->
     (lc_tm u) ->
     (lc_tm (tcons t u))
 | lc_choice : forall (t1 t2:tm),
     (lc_tm t1) ->
     (lc_tm t2) ->
     (lc_tm (choice t1 t2))
 | lc_fail : 
     (lc_tm fail)
 | lc_ex : forall (t:tm),
      ( forall x , lc_tm  ( open_tm_wrt_tm t (var_f x) )  )  ->
     (lc_tm (ex t))
 | lc_seq : forall (t1 t2:tm),
     (lc_tm t1) ->
     (lc_tm t2) ->
     (lc_tm (seq t1 t2))
 | lc_unify : forall (t1 t2:tm),
     (lc_tm t1) ->
     (lc_tm t2) ->
     (lc_tm (unify t1 t2))
 | lc_one : forall (t:tm),
     (lc_tm t) ->
     (lc_tm (one t))
 | lc_all : forall (t:tm),
     (lc_tm t) ->
     (lc_tm (all t)).
(** free variables *)
Fixpoint fv_tm (t_5:tm) : vars :=
  match t_5 with
  | (var_b nat) => {}
  | (var_f x) => {{x}}
  | (abs t) => (fv_tm t)
  | (app t u) => (fv_tm t) \u (fv_tm u)
  | (lit k) => {}
  | add => {}
  | tnil => {}
  | (tcons t u) => (fv_tm t) \u (fv_tm u)
  | (choice t1 t2) => (fv_tm t1) \u (fv_tm t2)
  | fail => {}
  | (ex t) => (fv_tm t)
  | (seq t1 t2) => (fv_tm t1) \u (fv_tm t2)
  | (unify t1 t2) => (fv_tm t1) \u (fv_tm t2)
  | (one t) => (fv_tm t)
  | (all t) => (fv_tm t)
end.

(** substitutions *)
Fixpoint subst_tm (t_5:tm) (x5:tmvar) (t__6:tm) {struct t__6} : tm :=
  match t__6 with
  | (var_b nat) => var_b nat
  | (var_f x) => (if eq_var x x5 then t_5 else (var_f x))
  | (abs t) => abs (subst_tm t_5 x5 t)
  | (app t u) => app (subst_tm t_5 x5 t) (subst_tm t_5 x5 u)
  | (lit k) => lit k
  | add => add 
  | tnil => tnil 
  | (tcons t u) => tcons (subst_tm t_5 x5 t) (subst_tm t_5 x5 u)
  | (choice t1 t2) => choice (subst_tm t_5 x5 t1) (subst_tm t_5 x5 t2)
  | fail => fail 
  | (ex t) => ex (subst_tm t_5 x5 t)
  | (seq t1 t2) => seq (subst_tm t_5 x5 t1) (subst_tm t_5 x5 t2)
  | (unify t1 t2) => unify (subst_tm t_5 x5 t1) (subst_tm t_5 x5 t2)
  | (one t) => one (subst_tm t_5 x5 t)
  | (all t) => all (subst_tm t_5 x5 t)
end.


Fixpoint is_value (t_5:tm) : Prop :=
  match t_5 with
  | (var_b nat) => False
  | (var_f x) => True
  | (abs t) => True
  | (app t u) => False
  | (lit k5) => True
  | (tcons t1 t2) => (is_value t1) /\
      match t2 with 
        | tnil => True
        | tcons _ _ => is_value t2
        | _ => False
      end
  | tnil => True
  | add => True
  | fail => False
  | choice t1 t2 => False
  | (ex t) => False
  | seq e1 e2 => False
  | unify e1 e2 => False
  | one e => False
  | all e => False
end.

Fixpoint nth (t : tm) (k : nat) :  option tm :=
  match t , k with 
  | tcons v w , 0 => Some v
  | tcons v w , S j => nth w j
  | _ , _  => None
  end.





(** definitions *)

(* defns JValue *)
Inductive listvalue : tm -> Prop :=    (* defn listvalue *)
 | lv_nil : 
     listvalue tnil
 | lv_cons : forall (v w:tm),
     value v ->
     listvalue w ->
     listvalue (tcons v w)
with value : tm -> Prop :=    (* defn value *)
 | sv_var : forall (x:tmvar),
     value (var_f x)
 | sv_abs : forall (t:tm),
     lc_tm (abs t) ->
     value  ( (abs t) ) 
 | sv_nil : 
     value tnil
 | sv_nat : forall (k:j),
     value (lit k)
 | sv_list : forall (v:tm),
     listvalue v ->
     value v
 | sv_add : 
     value add.

(* defns JBeta *)
Inductive beta : tm -> tm -> Prop :=    (* defn beta *)
 | beta_reduct : forall (t v:tm),
     lc_tm (abs t) ->
     value v ->
     beta (app  ( (abs t) )  v)  (open_tm_wrt_tm t v ) 
 | beta_app_0 : forall (v w t:tm),
     lc_tm t ->
     value  ( (tcons v w) )  ->
     beta (app  ( (tcons v w) )  (lit  0 )) t
 | beta_app_k : forall (v w:tm) (k:j),
     value  ( (tcons v w) )  ->
     beta (app  ( (tcons v w) )   ( (lit  (  1   +  k ) ) ) )  ( (app w (lit k)) ) 
 | beta_plus : forall (j5 k:j),
     beta (app add  ( (tcons (lit j5)  ( (tcons (lit k) tnil) ) ) ) )  ( (lit  ( j5  +  k ) ) ) .

(* defns JEta *)
Inductive eta : tm -> tm -> Prop :=    (* defn eta *)
 | eta_reduct : forall (L:vars) (t' t:tm),
      ( forall x , x \notin  L  ->   ( open_tm_wrt_tm t' (var_f x) )  = (app t (var_f x))  )  ->
     eta (abs t') t.

(* defns JBetaEta *)
Inductive betaeta : tm -> tm -> Prop :=    (* defn betaeta *)
 | eta_beta : forall (t u:tm),
     beta t u ->
     betaeta t u
 | eta_eta : forall (t u:tm),
     eta t u ->
     betaeta t u.

(* defns JGen *)
Inductive compatible_closure : relation -> tm -> tm -> Prop :=    (* defn compatible_closure *)
 | cc_rel : forall (R:relation) (t u:tm),
      R t u  ->
     compatible_closure R t u
 | cc_abs : forall (L:vars) (R:relation) (t u:tm),
      ( forall x , x \notin  L  -> compatible_closure R  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm u (var_f x) )  )  ->
     compatible_closure R (abs t) (abs u)
 | cc_app1 : forall (R:relation) (t u t':tm),
     lc_tm u ->
     compatible_closure R t t' ->
     compatible_closure R (app t u) (app t' u)
 | cc_app2 : forall (R:relation) (t u u':tm),
     lc_tm t ->
     compatible_closure R u u' ->
     compatible_closure R (app t u) (app t u')
 | cc_cons1 : forall (R:relation) (t u t':tm),
     lc_tm u ->
     compatible_closure R t t' ->
     compatible_closure R (tcons t u) (tcons t' u)
 | cc_cons2 : forall (R:relation) (t u u':tm),
     lc_tm t ->
     compatible_closure R u u' ->
     compatible_closure R (tcons t u) (tcons t u').

(* defns JRC *)
Inductive refl_closure : relation -> tm -> tm -> Prop :=    (* defn refl_closure *)
 | r_rel : forall (R:relation) (t u:tm),
      R t u  ->
     refl_closure R t u
 | r_refl : forall (R:relation) (t:tm),
     lc_tm t ->
     refl_closure R t t.

(* defns JTC *)
Inductive trans_closure : relation -> tm -> tm -> Prop :=    (* defn trans_closure *)
 | t_rel : forall (R:relation) (t u:tm),
      R t u  ->
     trans_closure R t u
 | t_trans : forall (R:relation) (t1 t3 t2:tm),
     trans_closure R t1 t2 ->
     trans_closure R t2 t3 ->
     trans_closure R t1 t3.

(* defns JRTC *)
Inductive refl_trans_closure : relation -> tm -> tm -> Prop :=    (* defn refl_trans_closure *)
 | rt_rel : forall (R:relation) (t u:tm),
      R t u  ->
     refl_trans_closure R t u
 | rt_refl : forall (R:relation) (t:tm),
     lc_tm t ->
     refl_trans_closure R t t
 | rt_trans : forall (R:relation) (t1 t3 t2:tm),
     refl_trans_closure R t1 t2 ->
     refl_trans_closure R t2 t3 ->
     refl_trans_closure R t1 t3.

(* defns JSTC *)
Inductive sym_trans_closure : relation -> tm -> tm -> Prop :=    (* defn sym_trans_closure *)
 | st_rel : forall (R:relation) (t u:tm),
      R t u  ->
     sym_trans_closure R t u
 | st_sym : forall (R:relation) (t u:tm),
     sym_trans_closure R u t ->
     sym_trans_closure R t u
 | st_trans : forall (R:relation) (t1 t3 t2:tm),
     sym_trans_closure R t1 t2 ->
     sym_trans_closure R t2 t3 ->
     sym_trans_closure R t1 t3.

(* defns JPar *)
Inductive parallel : tm -> tm -> Prop :=    (* defn parallel *)
 | p_beta : forall (t u t' v:tm),
     parallel t (abs t') ->
     parallel u v ->
     value v ->
     parallel (app t u)  (open_tm_wrt_tm t' v ) 
 | p_app_k : forall (t u w v:tm) (k:j),
     parallel t v ->
     parallel u (lit k) ->
     value v ->
      nth v k  = Some  w  ->
     parallel (app t u) w
 | p_add_beta : forall (t:tm) (j5 k:j),
     parallel t (tcons (lit j5)  ( (tcons (lit k) tnil) ) ) ->
     parallel (app add t)  ( (lit  ( j5  +  k ) ) ) 
 | p_var : forall (x:tmvar),
     parallel (var_f x) (var_f x)
 | p_abs : forall (L:vars) (t t':tm),
      ( forall x , x \notin  L  -> parallel  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm t' (var_f x) )  )  ->
     parallel (abs t) (abs t')
 | p_app : forall (t u t' u':tm),
     parallel t t' ->
     parallel u u' ->
     parallel (app t u) (app t' u')
 | p_cons : forall (t u t' u':tm),
     parallel t t' ->
     parallel u u' ->
     parallel (tcons t u) (tcons t' u')
 | p_nil : 
     parallel tnil tnil
 | p_add : 
     parallel add add
 | p_nat : forall (k:j),
     parallel (lit k) (lit k).

(* defns JOp *)
Inductive Step : tm -> tm -> Prop :=    (* defn Step *)
 | S_app1 : forall (t u t':tm),
     lc_tm u ->
     Step t t' ->
     Step (app t u) (app t' t)
 | S_beta : forall (t u:tm),
     lc_tm (abs t) ->
     lc_tm u ->
     Step (app  ( (abs t) )  u)  (open_tm_wrt_tm t u ) 
 | S_cons1 : forall (t u t':tm),
     lc_tm u ->
     Step t t' ->
     Step (tcons t u) (tcons t' t)
 | S_cons2 : forall (v t t':tm),
     Step t t' ->
     value v ->
     Step (tcons v t) (tcons v t')
 | S_prj_zero : forall (v w:tm),
     value  ( (tcons v w) )  ->
     Step (app  ( (tcons v w) )  (lit  0 )) v
 | S_prj_suc : forall (v w:tm) (k:j),
     value  ( (tcons v w) )  ->
     Step (app  ( (tcons v w) )   ( (lit  (  1   +  k ) ) ) ) (app  ( (tcons v w) )  (lit k))
 | S_add : forall (k1 k2:j),
     Step (app add  ( (tcons (lit k1) (lit k2)) ) ) (lit  ( k1  +  k2 ) ).

(* defns JOpV *)
Inductive StepV : tm -> tm -> Prop :=    (* defn StepV *)
 | SV_app1 : forall (t u t':tm),
     lc_tm u ->
     StepV t t' ->
     StepV (app t u) (app t' t)
 | SV_app2 : forall (v u u':tm),
     StepV u u' ->
     value v ->
     StepV (app v u) (app v u')
 | SV_betav : forall (t v:tm),
     lc_tm (abs t) ->
     value v ->
     StepV (app  ( (abs t) )  v)  (open_tm_wrt_tm t v ) 
 | SV_prj_zero : forall (v w:tm),
     value  ( (tcons v w) )  ->
     StepV (app  ( (tcons v w) )  (lit  0 )) v
 | SV_prj_suc : forall (v w:tm) (k:j),
     value  ( (tcons v w) )  ->
     StepV (app  ( (tcons v w) )   ( (lit  (  1   +  k ) ) ) ) (app  ( (tcons v w) )  (lit k))
 | SV_add : forall (k1 k2:j),
     StepV (app add  ( (tcons (lit k1) (lit k2)) ) ) (lit  ( k1  +  k2 ) ).

(* defns JEval *)
Inductive Eval : tm -> tm -> Prop :=    (* defn Eval *)
 | E_beta : forall (t u v t':tm),
     Eval t (abs t') ->
     Eval  (open_tm_wrt_tm t' u )  v ->
     Eval (app t u) v.

(* defns JEq *)
Inductive conversion : tm -> tm -> Prop :=    (* defn conversion *)
 | eq_beta : forall (t u:tm),
     lc_tm (abs t) ->
     lc_tm u ->
     conversion (app  ( (abs t) )  u)  (open_tm_wrt_tm t u ) 
 | eq_refl : forall (t:tm),
     lc_tm t ->
     conversion t t
 | eq_sym : forall (t u:tm),
     conversion u t ->
     conversion t u
 | eq_trans : forall (t1 t3 t2:tm),
     conversion t1 t2 ->
     conversion t2 t3 ->
     conversion t1 t3
 | eq_app1 : forall (t u t':tm),
     lc_tm u ->
     conversion t t' ->
     conversion (app t u) (app t' u)
 | eq_app2 : forall (t u u':tm),
     lc_tm t ->
     conversion u u' ->
     conversion (app t u) (app t u')
 | eq_abs : forall (L:vars) (t t':tm),
      ( forall x , x \notin  L  -> conversion  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm t' (var_f x) )  )  ->
     conversion (abs t) (abs t')
 | eq_cons1 : forall (t u t':tm),
     lc_tm u ->
     conversion t t' ->
     conversion (tcons t u) (tcons t' u)
 | eq_cons2 : forall (t u u':tm),
     lc_tm t ->
     conversion u u' ->
     conversion (tcons t u) (tcons t u').

(* defns JRed *)
Inductive full_reduction : tm -> tm -> Prop :=    (* defn full_reduction *)
 | F_beta : forall (t v:tm),
     lc_tm (abs t) ->
     value v ->
     full_reduction (app  ( (abs t) )  v)  (open_tm_wrt_tm t v ) 
 | F_abs : forall (L:vars) (t t':tm),
      ( forall x , x \notin  L  -> full_reduction  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm t' (var_f x) )  )  ->
     full_reduction (abs t) (abs t')
 | F_app1 : forall (t u t':tm),
     lc_tm u ->
     full_reduction t t' ->
     full_reduction (app t u) (app t' u)
 | F_app2 : forall (t u u':tm),
     lc_tm t ->
     full_reduction u u' ->
     full_reduction (app t u) (app t u')
 | F_cons1 : forall (t u t':tm),
     lc_tm u ->
     full_reduction t t' ->
     full_reduction (tcons t u) (tcons t' u)
 | F_cons2 : forall (t u u':tm),
     lc_tm t ->
     full_reduction u u' ->
     full_reduction (tcons t u) (tcons t u')
 | F_prj_zero : forall (v w:tm),
     value v ->
     listvalue w ->
     full_reduction (app  ( (tcons v w) )  (lit  0 )) v
 | F_prj_suc : forall (v w:tm) (k:j),
     value v ->
     listvalue w ->
     full_reduction (app  ( (tcons v w) )   ( (lit  (  1   +  k ) ) ) ) (app w (lit k))
 | F_add : forall (k1 k2:j),
     full_reduction (app add  ( (tcons (lit k1)  ( (tcons (lit k2) tnil) ) ) ) ) (lit  ( k1  +  k2 ) ).

(* defns Jredex *)
Inductive redex : relation -> tm -> Prop :=    (* defn redex *)
 | redex_def : forall (R:relation) (t u:tm),
      R t u  ->
     redex R t.

(* defns Jterminal *)
Inductive terminal : relation -> tm -> Prop :=    (* defn terminal *)
 | terminal_def : forall (R:relation) (t u:tm),
      (forall  u ,   not (  R t u  )  )  ->
     terminal R t.

(* defns JNF *)
Inductive nf : relation -> tm -> Prop :=    (* defn nf *)
 | nf_var : forall (R:relation) (x:tmvar),
      not ( redex R (var_f x) )  ->
     nf R (var_f x)
 | nf_abs : forall (L:vars) (R:relation) (t:tm),
      ( forall x , x \notin  L  -> nf R  ( open_tm_wrt_tm t (var_f x) )  )  ->
      not ( redex R  ( (abs t) )  )  ->
     nf R  ( (abs t) ) 
 | nf_app : forall (R:relation) (t u:tm),
     nf R t ->
     nf R u ->
      not ( redex R  ( (app t u) )  )  ->
     nf R  ( (app t u) ) .

(* defns JParCC *)
Inductive cc_parallel : relation -> tm -> tm -> Prop :=    (* defn cc_parallel *)
 | cc_par_rel : forall (R:relation) (t u:tm),
      R t u  ->
     cc_parallel R t u
 | cc_par_refl : forall (R:relation) (t:tm),
     lc_tm t ->
     cc_parallel R t t
 | cc_par_abs : forall (L:vars) (R:relation) (t u:tm),
      ( forall x , x \notin  L  -> cc_parallel R  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm u (var_f x) )  )  ->
     cc_parallel R (abs t) (abs u)
 | cc_par_app : forall (R:relation) (t u t' u':tm),
     cc_parallel R t t' ->
     cc_parallel R u u' ->
     cc_parallel R (app t u) (app t' u')
 | cc_par_cons : forall (R:relation) (t u t' u':tm),
     cc_parallel R t t' ->
     cc_parallel R u u' ->
     cc_parallel R (tcons t u) (tcons t' u').

(* defns JParSynCC *)
Inductive cc_parallel2 : relation -> tm -> tm -> Prop :=    (* defn cc_parallel2 *)
 | cc_p_refl : forall (R:relation) (t:tm),
     lc_tm t ->
     cc_parallel2 R t t
 | cc_p_abs : forall (L:vars) (R:relation) (t u:tm),
      ( forall x , x \notin  L  -> cc_parallel2 R  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm u (var_f x) )  )  ->
     cc_parallel2 R (abs t) (abs u)
 | cc_p_app : forall (R:relation) (t u t' u':tm),
     cc_parallel2 R t t' ->
     cc_parallel2 R u u' ->
     cc_parallel2 R (app t u) (app t' u')
 | cc_p_var_rel : forall (R:relation) (x:tmvar) (u:tm),
      R (var_f x) u  ->
     cc_parallel2 R (var_f x) u
 | cc_p_abs_rel : forall (L:vars) (R:relation) (t u' u:tm),
      ( forall x , x \notin  L  -> cc_parallel2 R  ( open_tm_wrt_tm t (var_f x) )   ( open_tm_wrt_tm u (var_f x) )  )  ->
      R  ( (abs u) )  u'  ->
     cc_parallel2 R (abs t) u'
 | cc_p_app_rel : forall (R:relation) (t u t'' t' u':tm),
     cc_parallel2 R t t' ->
     cc_parallel2 R u u' ->
      R  ( (app t' u') )  t''  ->
     cc_parallel2 R (app t u) t''.


(** infrastructure *)
Hint Constructors listvalue value beta eta betaeta compatible_closure refl_closure trans_closure refl_trans_closure sym_trans_closure parallel Step StepV Eval conversion full_reduction redex terminal nf cc_parallel cc_parallel2 lc_tm : core.


