Require Import verse.syntax.
Require Import fintype.

(* This file defines the reduction system presented in the ICFP paper
   
   These rules were originally generated by Ott, but have been modified by
   hand for well-scoped de Bruijn indices generated by Autosubst

*)

Set Implicit Arguments.

Module VerseNotation.
End VerseNotation.

Definition replace {n} (x : fin n) (v : Val n) : fin n -> Val n := 
  fun y => if fin_eqb x y then v else (var_Val y).


Module AutosubstNotation. 
Notation "↑" := shift : subst_scope.
Notation " x ↦ v " := (replace x v) (at level 60) : subst_scope.
End AutosubstNotation.

Import AutosubstNotation.
Open Scope subst_scope.
Print Visibility subst_scope.

Check ( (Int 3) ⟨↑⟩ ).




Inductive program : Type :=  (*r programs *)
 | p_one (e:Exp 0).


(** * ----------------- Contexts and Hole plugging --------------- *)
(* Fig. 4*)

(** ** Execution contexts X *)

(*
Inductive exContext (n : nat) : Type :=  (*r execution contexts *)
 | X_hole : exContext n
 | X_eq_right (v:Val n) (X:exContext n) (e:Exp n)
 | X_seq_left (X:exContext n) (e:Exp n)
 | X_seq_right (eq5:Exp n) (X:exContext n).

Arguments X_hole {_}.
*)

(** ** Value contexts V and value list contexts VS *) 

Inductive ValContext (n : nat) : Type :=  (*r Val contexts *)
 | Vhole : ValContext n
 | Vcons (VX:ValListContext n) 
with ValListContext (n : nat) : Type :=  (*r Val list context *)
 | VXconsleft (V:ValContext n) (vs: list (Val n))
 | VXconsright (v:Val n) (VX:ValListContext n).

Arguments Vhole {_}.

(** ** Scope contexts SX and SC *)

(*
Inductive SC (n : nat) : Type :=  (*r scope contexts *)
 | SC_choice_hole : SC n
 | SC_choice_left (SC5:SC n) (e:Exp n)
 | SC_choice_right (e:Exp n) (SC5:SC n).

Arguments SC_choice_hole {_}.

Inductive scopeContext (n : nat) : Type :=  (*r scope contexts *)
 | SX_one (SC5:SC n)
 | SX_all (SC5:SC n).
*)

(** ** Choice contexts CX *)

(*
Inductive choiceContext (n : nat) : Type :=  (*r choice contexts *)
 | CX_hole : choiceContext n
 | CX_choice_right (v:Val n) (CX:choiceContext n) (e:Exp n)
 | CX_seq_left (CX:choiceContext n) (e:Exp n)
 | CX_seq_right (ceq5:Exp n) (CX:choiceContext n)
 | CX_exists (CX:choiceContext (S n)).

Arguments CX_hole {_}.
*)

(** ** Choice-free expressions ce *)

Fixpoint is_choice_free_of_exp {n} (e_5:Exp n) : Prop :=
  match e_5 with
  | (Ret v) => (True)
  | (App v1 v2) => (True)
  | (Unify v1 e) => is_choice_free_of_exp e
  | (Seq e1 e2) => ((is_choice_free_of_exp e1) /\ (is_choice_free_of_exp e2))
  | (Exists e) => ((is_choice_free_of_exp e))
  | (Or e1 e2) => False
  | Fail => False
  | (One e) => (True)
  | (All e) => (True)
end.


(** ** Other contexts *)

(*

Inductive Exp_compat_context (n : nat) : Type := 
 | E_Hole : Exp_compat_context n
 | E_Seq1 (E:Exp_compat_context n) (e:Exp n)
 | E_Seq2 (v:Exp n) (E:Exp_compat_context n)
 | E_Unify1 (VE:Val_compat_context n) (e:Exp n)
 | E_Unify2 (v:Val n) (E:Exp_compat_context n)
 | E_Exists (E:Exp_compat_context (S n))
 | E_Or1 (E:Exp_compat_context n) (e:Exp n)
 | E_Or2 (e:Exp n) (E:Exp_compat_context n)
 | E_One (E:Exp_compat_context n)
 | E_All (E:Exp_compat_context n)
 | E_App1 (VE:Val_compat_context n) (v:Val n)
 | E_App2 (v:Val n) (VE:Val_compat_context n)
 | E_Ret (VE:Val_compat_context n)
with Val_compat_context (n : nat) : Type := 
 | V_Tuple (VLE:Val_list_compat_context n)
 | V_Lam (E:Exp_compat_context (S n))
with Val_list_compat_context (n : nat) : Type := 
 | VE_cons1 (VE:Val_compat_context n) (vs:list (Val n))
 | VE_cons2 (v:Val n) (VLE:Val_list_compat_context n).

Arguments E_Hole {_}.

Inductive exists_context (n : nat) : Type :=  (*r exists contexts *)
 | EX_X (X:exContext n)
 | EX_exists (EX:exists_context n). 

*)

(** ** Plugging contexts *)

Print Exp.

Fixpoint plug_exp {n} ( x : exContext n) ( e : Exp n ) : Exp n :=
   match x with 
   | Xhole => e
   | Xeqright v X e2 => Seq (Unify v (plug_exp X e)) e2
   | Xseqleft X e1 => Seq (plug_exp X e) e1
   | Xseqright e1 X => Seq e1 (plug_exp X e)
   end.

Fixpoint plug_value_list {n} (x : ValListContext n) (v : Val n) : list (Val n) :=
  match x with 
   | VXconsleft V vs => (plug_value V v) :: vs
   | VXconsright v1 VX => v1 :: (plug_value_list VX v)
  end
with 
  plug_value {n} ( x : ValContext n) ( v : Val n ) : Val n :=
   match x with 
   | Vhole => v
   | Vcons VX  => Tuple (plug_value_list VX v)
   end.

Fixpoint plug_sc {n} (sc : SC n) (e:Exp n): Exp n :=
  match sc with 
  | SCchoicehole => e 
  | SCchoiceleft sc e2 => Or (plug_sc sc e) e2
  | SCchoiceright e1 sc => Or e1 (plug_sc sc e)
  end.

Definition plug_scope {n} (sx : scopeContext n) (e : Exp n) : Exp n := 
  match sx with  
  | SXone sc => One (plug_sc sc e)
  | SXall sc => All (plug_sc sc e)
  end.

Fixpoint plug_choice {n} (cx : choiceContext n) (e : Exp n) : Exp n :=
  match cx with 
  | CXhole => e
  | CXchoiceright v cx2 e1 => Seq (Unify v (plug_choice cx2 e)) e1
  | CXseqleft cx1 e2 => Seq (plug_choice cx1 e) e2
  | CXseqright e1 cx2 => Seq e1 (plug_choice cx2 e)
  | CXexists cx1 => Exists (plug_choice cx1 (ren_Exp shift e))
  end.

(*
Fixpoint plug_eexp {n} ( x : existsContext n) ( e : Exp n ) : Exp n :=
   match x with 
   | EX_X X => plug_exp X e
   | EX_exists EX => plug_eexp EX e
 end.
*)

Fixpoint plug_expContext {n}
  (E : ExpCompatContext n) (e : Exp n) :=
    match E with 
    | EHole _ => e 
    | ESeq1 E e1 =>
         Seq (plug_expContext E e) e1
    | ESeq2 e E => 
        Seq e (plug_expContext E e)
    | EUnify1 E e1 => 
        Unify (plug_valContext E e) e1
    | EUnify2 e2 E => 
        Unify e2 (plug_expContext E e)

    | EExists E => 
        Exists (plug_expContext E (e ⟨↑⟩ ))

    | EOr1 E e1 => 
        Or (plug_expContext E e) e1
    | EOr2 e2 E => 
        Or e2 (plug_expContext E e)
    | EOne E => One (plug_expContext E e)
    | EAll E => All (plug_expContext E e)
    | EApp1 E v =>
        App (plug_valContext E e) v
    | EApp2 v E => 
        App  v (plug_valContext E e)
    | ERet V =>
        Ret (plug_valContext V e)
        end
   with plug_valContext {n} (V : ValCompatContext n) (e:Exp n) :=
    match V with
    | VTuple VE => Tuple (plug_ve VE e)
    | VLam E => Lam (plug_expContext E e⟨↑⟩)
    end
  with plug_ve {n} (VE : ValListCompatContext n) (e:Exp n) :=
   match VE with 
   | VEcons1 E vs => cons (plug_valContext E e) vs
   | VEcons2 v VE => cons v (plug_ve VE e)
   end.

Module PlugNotation. 

(* Don't conflict with autosubst substitution notation *)
Class ContextNotation (C : Type) (H : Type) (S : Type) := plug : C -> H -> S.
Notation " X {{ e }} " := (plug X e) (at level 60).
Instance ExContextNotation  {n} : ContextNotation (exContext n) (Exp n) (Exp n) := plug_exp.
(*
Instance EExpContextNotation {n} : ContextNotation (existsContext n) (Exp n) (Exp n) :=
  plug_eexp.
*)
Instance EccContextNotation {n} : ContextNotation (ExpCompatContext n) (Exp n) (Exp n) := 
  plug_expContext.
Instance VccContextNotation {n} : ContextNotation (ValCompatContext n) (Exp n) (Val n) := 
  plug_valContext.
Instance VlccContextNotation {n} : ContextNotation (ValListCompatContext n) (Exp n) (list (Val n)) := 
  plug_ve.
Instance scopeContextNotation {n} : ContextNotation (scopeContext n) (Exp n) (Exp n) := 
  plug_scope.
Instance choiceContextNotation {n} : ContextNotation (choiceContext n) (Exp n) (Exp n) := 
  plug_choice.

End PlugNotation.

Import PlugNotation.

(** * Rewrite rule sets and rules *)

(* Sets of rewrite rules *)

Inductive ruleset : Type :=  (*r sets of rewrite rules *)
 | Rule_A : ruleset (*r application *)
 | Rule_U : ruleset (*r unification *)
 | Rule_E {n:nat} (E:ExpCompatContext n) (*r elimination *) 
 | Rule_N : ruleset (*r normalization *)
 | Rule_C : ruleset (*r choice *).

Definition is_head_normal_form_of_value {n} (v5:Val n) : Prop :=
  match v5 with
  | (var_Val x) => False
  | (Prim op5) => (True)
  | (Int k) => (True)
  | (Tuple vs) => (True)
  | (Lam e) => (True)
end.

(* two values have observably different heads *)

Inductive diff_head {n} : Val n -> Val n -> Prop :=  
 | diff_nat : forall (k1 k2:nat),
    (@Int n k1) <> (Int k2)  ->
     diff_head (Int k1) (Int k2)
 | diff_left_nat : forall (k:nat) vs,
     diff_head (Int k) (Tuple vs)
 | diff_right_nat : forall vs (k:nat),
     diff_head (Tuple vs) (Int k)
 | diff_left_op : forall (op5:Op) hnf,
     diff_head (Prim op5) hnf
 | diff_right_op : forall hnf (op5:Op),
     diff_head hnf (Prim op5)
 | diff_left_abs : forall e hnf,
     diff_head (Lam e) hnf
 | diff_right_abs : forall hnf e,
     diff_head hnf (Lam e).

Notation "'var'" := (var_Val) (at level 1) : subst_scope.

(* defns Jprj *)
Inductive prj_tuple {n} : list (Val n) -> Val n -> nat -> Exp n -> Prop :=    (* defn prj_tuple *)

 | prj_tuple_nil : forall x i,
     prj_tuple nil x i Fail

 | prj_tuple_cons : forall v0 vs x i e,
     prj_tuple vs x (S i) e ->
     prj_tuple (v0 :: vs) x i (Or (Seq (Unify x (Ret (Int i))) (Ret v0)) e).


Inductive unify_tuple {n} : 
  list (Val n) -> list (Val n) -> Exp n -> Exp n -> Prop :=    

 | unify_tuple_nil : forall e,
     unify_tuple nil nil e e

 | unify_tuple_cons : forall v0 vs0 v1 vs1 e1 e2,
     unify_tuple vs0 vs1 e1 e2 ->
     unify_tuple (v0 :: vs0) (v1 :: vs1) e1 (Seq (Unify v0 (Ret v1)) e2).

(** * Rewrite rules Fig 3. *)

Inductive reduction_step {n} : ruleset -> Exp n ->  Exp n -> Prop := 

 (* Application: *)
 | app_add : forall (k1 k2:nat),
     reduction_step Rule_A 
       (App (Prim opAdd) (Tuple (cons (Int k1) (cons (Int k2) nil)))) 
       (Ret (Int (k1 + k2)))

 | app_gt : forall (k1 k2:nat),
      k1 > k2  ->
     (* ------------------ *)
     reduction_step Rule_A 
       (App (Prim opGt) (Tuple (cons (Int k1) (cons (Int k2) nil)))) 
       (Ret (Int k1))

 | app_gt_fail : forall (k1 k2:nat),
     k1 <= k2  ->
     reduction_step Rule_A 
       (App (Prim opGt) (Tuple (cons (Int k1) (cons (Int k2) nil)))) 
       Fail

 | app_beta : forall (e:Exp (S n)) (v:Val n),

     reduction_step Rule_A 
       (App (Lam e) v) 
       (Exists (Seq (Unify (var var_zero) (Ret (ren_Val shift v))) e))

 | app_tup : forall (vs: list (Val n)) (v:Val n) (e:Exp n),
   (* NOTE: The app_tup rule is slightly different than in the paper 

      < v0 ... vn > v  ->  exists x. x = v ; ( x = 0 ; v0 ) || ... || ( x = n ; vn ) 

   this rule skips the let binding and uses v directly

      < v0 ... vn > v  ->  ( v = 0 ; v0 ) || ... || ( v = n ; vn ) 

   *)

     prj_tuple vs v 0 e ->
     reduction_step Rule_A  (App (Tuple vs) v) e

 (* Unification *)
 | u_lit : forall (k:nat) (e:Exp n),

     reduction_step Rule_U 
       (Seq (Unify (Int k) (Ret (Int k))) e) e

 | u_tup : forall (vs1:list (Val n)) (vs2:list (Val n)) (e1 e2:Exp n),
     unify_tuple vs1 vs2 e1 e2 ->
     reduction_step Rule_U (Seq (Unify (Tuple vs1) (Ret (Tuple vs2))) e1) e2 

 | u_fail : forall (e:Exp n) (hnf1 hnf2: Val n),
     is_head_normal_form_of_value hnf1 ->
     is_head_normal_form_of_value hnf2 ->
     diff_head hnf1 hnf2 ->
     reduction_step Rule_U (Seq (Unify hnf1 (Ret hnf2)) e) Fail

 | u_occurs : forall (x:fin n) (V:ValContext n) (e:Exp n),
     (V <> Vhole) ->
     reduction_step Rule_U 
       (Seq (Unify (var x) (Ret (plug_value V (var x)))) e) Fail

 | subst : forall (X:exContext n) (x:fin n) (v:Val n) (e:Exp n),
     (* TODO: substitute in context *)
     reduction_step Rule_U
       (X  {{ Seq (Unify (var x) (Ret v)) e }})
       (X  {{ Seq (Unify (var x) (Ret v)) (e[ x ↦ v ]) }})

 | hnf_swap : forall (x:fin n) (e:Exp n) hnf,
     is_head_normal_form_of_value hnf ->
     reduction_step Rule_U 
       (Seq (Unify hnf (Ret (var x))) e) 
       (Seq (Unify (var x) (Ret hnf)) e)

 | var_swap : forall (y x:fin n) (e:Exp n),
     (* TODO: scope_lt S x y -> *)
     reduction_step  Rule_U
       ((Seq (Unify (var y) (Ret (var x))) e))   
       ((Seq (Unify (var x) (Ret (var y))) e))

 | seq_swap : forall (v1:Val n) (e1:Exp n) (x:fin n) (v:Val n) (e:Exp n),
     (* TODO not (exists n, v1  = (var y) /\  scope_le S y x) -> *) 
     reduction_step  Rule_U
       (Seq (Unify v1 e1) ((Seq (Unify (var x) (Ret v)) e)))
       (Seq (Unify (var x) (Ret v)) ((Seq (Unify v1 e1) e)))
 (* Elimination *)
 | val_elim : forall (v:Val n) (e:Exp n) (E:ExpCompatContext n),

     reduction_step (Rule_E E)
       (Seq (Ret v) e) e

 | exi_elim : forall (e:Exp (S n)) (e' : Exp n) (E:ExpCompatContext n),
      (* TODO: strengthen_Exp e e' -> *)
      reduction_step (Rule_E E) 
        (Exists e) e'

(* TODO *)
(*
 | eqn_elim : forall (e:Exp n) (E:ExpCompatContext) (X:exContext n) (v:val n),
      reduction_step (Rule_E E) 
       Exists (X {{ Seq (Unify x v) e }}) (X {{ e }})
*)

 | fail_elim : forall (X:exContext n) (E:ExpCompatContext n),
     reduction_step (Rule_E E)  (X {{ Fail }}) Fail

 (* normalization *)
 | exi_float : forall  (X:exContext n) (e :Exp (S n)),
     reduction_step Rule_N
       ( X {{ Exists e }}) 
       ( Exists ( X[ shift >> var_Val ] {{ e }}) ) 

 | seq_assoc : forall (v : Val n) (e1 e2 e3 : Exp n),
     reduction_step Rule_N 
       (Seq (Seq (Unify v e1) e2) e3) 
       (Seq (Unify v e1) (Seq e2 e3))
 | eqn_float : forall v1 v2 (e2 e3 e:Exp n),
     reduction_step Rule_N
       (Seq (Unify v1 (Seq (Unify v2 e2) e3)) e)
       (Seq (Unify v2 e2) (Seq (Unify v1 e3) e))

(* No need for this??
 | exi_swap : forall (e:exp),
     reduction_step (e_exists (e_exists e)) Rule_N (e_exists (e_exists e))
 *)
 (* Choice *)
 | onFail : 
     reduction_step Rule_C (One Fail) Fail
 | onRetue : forall v,
     reduction_step Rule_C (One (Ret v)) (Ret v)

 | one_choice : forall v e,
     reduction_step Rule_C 
       (One (Or (Ret v) e)) (Ret v)

 | all_fail :
     reduction_step Rule_C (All Fail) (Ret (Tuple nil))

 | all_value : forall v,
     reduction_step Rule_C (All (Ret v))
       (Ret (Tuple (cons v nil)))

 | all_choice : forall e vs,
     (* TODO : choice_tuple e vs -> *)
     reduction_step Rule_C (All e) (Ret (Tuple vs))

 | choose_r : forall e,
     reduction_step Rule_C (Or Fail e) e
 | choose_l : forall e,
     reduction_step Rule_C (Or e Fail) e
 | choose_assoc : forall e1 e2 e3,
     reduction_step Rule_C (Or (Or e1 e2) e3) (Or e1 ((Or e2 e3)))
 | choose : forall (SX:scopeContext n) (CX:choiceContext n) (e1 e2:Exp n),
     (CX <> CXhole) ->
     reduction_step Rule_C
       (SX {{ CX {{ Or e1 e2 }} }} )
       (SX {{ Or (CX {{e1}}) (CX{{e2}}) }}) .

(* --------------------------------------------------------------- *)

